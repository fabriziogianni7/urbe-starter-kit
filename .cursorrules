# Web3 Starter Kit - Cursor AI Context Rules

## Project Overview
This is a comprehensive Web3 starter kit for students learning blockchain development. The project uses:
- **React** for frontend development
- **Wagmi** for Ethereum interactions
- **Foundry** for smart contract development
- **Civic** for Web3 authentication
- **TypeScript** for type safety

## Technology Stack Context

### Frontend (React + TypeScript)
- Use functional components with hooks
- Implement proper TypeScript types for all Web3 interactions
- Use React Query for data fetching and caching
- Implement proper error boundaries for Web3 errors
- Use React Router for navigation
- Follow React best practices and hooks patterns

### Wagmi (Web3 React Hooks)
- Use `useAccount()` for wallet connection state
- Use `useContractRead()` for reading smart contract data
- Use `useContractWrite()` for writing to smart contracts
- Use `useBalance()` for token balances
- Use `useNetwork()` for network switching
- Always handle loading and error states
- Implement proper transaction status tracking

### Foundry (Smart Contracts)
- Use Solidity 0.8.19+ with latest features
- Implement proper access control with OpenZeppelin
- Use events for important state changes
- Implement proper error handling with custom errors
- Follow security best practices (reentrancy, overflow, etc.)
- Use NatSpec documentation for all public functions
- Implement proper testing with Foundry's testing framework

### Civic Authentication
- Civic provides Web3 authentication with multiple login options
- Supports SSO (Google, Apple, X, Facebook, Discord, GitHub)
- Supports email authentication
- Provides embedded wallet capabilities
- Integrates with major chains out of the box
- Use Civic's React SDK: `@civic/auth-web3`

## Code Style and Patterns

### React Components
```typescript
// Example component structure
interface ComponentProps {
  // Define clear prop types
}

const Component: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  // Use custom hooks for Web3 logic
  const { data, isLoading, error } = useWeb3Hook();
  
  // Handle loading states
  if (isLoading) return <LoadingSpinner />;
  
  // Handle error states
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div>
      {/* Component JSX */}
    </div>
  );
};
```

### Wagmi Hooks Usage
```typescript
// Example Wagmi hook usage
const { data: balance, isLoading } = useBalance({
  address: account?.address,
  watch: true,
});

const { write, isLoading: isWriting } = useContractWrite({
  address: contractAddress,
  abi: contractABI,
  functionName: 'functionName',
});
```

### Smart Contract Patterns
```solidity
// Example smart contract structure
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract ExampleContract is Ownable, ReentrancyGuard {
    // Events
    event ValueUpdated(uint256 newValue);
    
    // State variables
    uint256 private _value;
    
    // Custom errors
    error InvalidValue();
    
    // Functions
    function setValue(uint256 newValue) external onlyOwner {
        if (newValue == 0) revert InvalidValue();
        _value = newValue;
        emit ValueUpdated(newValue);
    }
    
    function getValue() external view returns (uint256) {
        return _value;
    }
}
```

## Civic Integration Guidelines

### Civic Setup
1. Install Civic SDK: `npm install @civic/auth-web3`
2. Configure Civic client in environment variables
3. Set up redirect URIs in Civic dashboard
4. Implement authentication flow with Civic hooks

### Civic Authentication Flow
```typescript
// Example Civic integration
import { CivicAuthProvider, useUser } from '@civic/auth-web3/react';

// Provider setup
<CivicAuthProvider clientId={process.env.VITE_CIVIC_CLIENT_ID}>
  {/* Your app components */}
</CivicAuthProvider>

// Using the hook
const { user, authStatus, signIn, signOut, isLoading, error } = useUser();

// Handle authentication
const handleSignIn = () => {
  signIn();
};

// Check authentication status
const isAuthenticated = authStatus === 'authenticated';
```

### Civic UserButton Component
```typescript
import { UserButton } from '@civic/auth-web3/react';

// Basic usage
<UserButton />

// With custom styling
<UserButton 
  className="civic-user-button"
  dropdownButtonClassName="civic-dropdown-button"
  style={{ minWidth: "20rem" }}
  dropdownButtonStyle={{ backgroundColor: "red" }}
/>
```

### Civic Web3 Wallet Integration
```typescript
// Creating a wallet for new users
import { userHasWallet } from "@civic/auth-web3";
import { useUser } from "@civic/auth-web3/react";

const createWallet = async () => {
  const userContext = await useUser();
  if (userContext.user && !userHasWallet(userContext)) {
    await userContext.createWallet();
  }
};

// Using with Wagmi
import { embeddedWallet } from "@civic/auth-web3/wagmi";
import { useAutoConnect } from "@civic/auth-web3/wagmi";

// Add to Wagmi config
const wagmiConfig = createConfig({
  chains: [mainnet, sepolia],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
  connectors: [
    embeddedWallet(),
  ],
});

// Auto-connect hook
useAutoConnect(); // Creates wallet and connects automatically
```

### Civic User Object Structure
```typescript
interface CivicUser {
  id: string;
  email?: string;
  name?: string;
  picture?: string;
  given_name?: string;
  family_name?: string;
  updated_at?: Date;
}

// Web3 User Context
type ExistingWeb3UserContext = UserContext & {
  ethereum: {
    address: string;
    wallet: WalletClient;
  }
}

type NewWeb3UserContext = UserContext & {
  createWallet: () => Promise<void>;
  walletCreationInProgress: boolean;
}
```

### Civic Authentication Status
```typescript
enum AuthStatus {
  AUTHENTICATED = "authenticated",
  UNAUTHENTICATED = "unauthenticated",
  AUTHENTICATING = "authenticating",
  ERROR = "error",
  SIGNING_OUT = "signing_out",
}
```

### Civic Configuration Options
```typescript
<CivicAuthProvider
  clientId="YOUR_CLIENT_ID"           // Required
  onSignIn={(error?: Error) => {}}    // Optional callback
  onSignOut={() => {}}                // Optional callback
  redirectUrl="/authenticating"       // Optional redirect URL
  iframeMode="embedded"               // Optional: "embedded" | "modal"
  displayMode="iframe"                // Optional: "iframe" | "redirect" | "new_tab"
  initialChain={mainnet}              // Optional: initial blockchain
  chains={[mainnet, polygon]}         // Optional: supported chains
/>
```

## File Structure Conventions

### Frontend Structure
```
frontend/src/
├── components/          # Reusable UI components
│   ├── ui/            # Basic UI components
│   ├── web3/          # Web3-specific components
│   └── civic/         # Civic authentication components
├── hooks/              # Custom React hooks
│   ├── web3/          # Web3-related hooks
│   └── civic/         # Civic-related hooks
├── pages/              # Page components
├── utils/              # Utility functions
│   ├── web3/          # Web3 utilities
│   └── civic/         # Civic utilities
├── types/              # TypeScript type definitions
├── constants/          # Application constants
└── wagmi/              # Wagmi configuration
```

### Smart Contract Structure
```
contracts/
├── src/                # Smart contracts
│   ├── interfaces/     # Contract interfaces
│   ├── libraries/      # Shared libraries
│   └── upgrades/       # Upgradeable contracts
├── test/               # Contract tests
├── script/             # Deployment scripts
└── foundry.toml        # Foundry configuration
```

## Best Practices

### Security
- Always validate user inputs
- Use proper access control mechanisms
- Implement reentrancy guards where needed
- Use safe math operations (Solidity 0.8+ handles this)
- Validate contract addresses before interactions
- Handle failed transactions gracefully

### Error Handling
- Implement comprehensive error handling for Web3 operations
- Provide user-friendly error messages
- Log errors for debugging
- Handle network errors and timeouts
- Implement retry mechanisms for failed transactions

### Performance
- Optimize smart contract gas usage
- Implement proper caching strategies
- Use React.memo for expensive components
- Implement proper loading states
- Optimize bundle size

### Testing
- Write comprehensive unit tests for smart contracts
- Test all possible scenarios including edge cases
- Implement integration tests for Web3 interactions
- Test error conditions and edge cases
- Use proper mocking for external dependencies

## Common Patterns

### Wallet Connection
```typescript
const { address, isConnected, isConnecting } = useAccount();
const { connect, connectors } = useConnect();

const handleConnect = () => {
  if (connectors[0]) {
    connect({ connector: connectors[0] });
  }
};
```

### Contract Interaction
```typescript
const { data, isLoading, error } = useContractRead({
  address: contractAddress,
  abi: contractABI,
  functionName: 'functionName',
  args: [arg1, arg2],
});

const { write, isLoading: isWriting } = useContractWrite({
  address: contractAddress,
  abi: contractABI,
  functionName: 'functionName',
});
```

### Transaction Handling
```typescript
const { write, isLoading, isSuccess, isError, error } = useContractWrite({
  address: contractAddress,
  abi: contractABI,
  functionName: 'functionName',
});

const handleTransaction = () => {
  write({
    args: [arg1, arg2],
    onSuccess: (data) => {
      console.log('Transaction successful:', data);
    },
    onError: (error) => {
      console.error('Transaction failed:', error);
    },
  });
};
```

## Environment Variables
Always use environment variables for:
- RPC URLs
- Contract addresses
- API keys
- Civic client IDs
- Private keys (for deployment only)

## Documentation
- Document all public functions with NatSpec
- Include examples in README
- Document deployment procedures
- Include troubleshooting guides
- Document security considerations

## Code Review Checklist
- [ ] TypeScript types are properly defined
- [ ] Error handling is implemented
- [ ] Loading states are handled
- [ ] Security best practices are followed
- [ ] Tests are written and passing
- [ ] Documentation is updated
- [ ] Gas optimization is considered
- [ ] User experience is considered

## Resources
- [Wagmi Documentation](https://wagmi.sh/)
- [Foundry Book](https://book.getfoundry.sh/)
- [Civic Documentation](https://docs.civic.com/)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)
- [Ethereum Development](https://ethereum.org/developers/)

## Documentation References

This project includes comprehensive documentation in the `docs/` folder:

### 📚 Project Documentation
- **`docs/civic.md`** - Complete Civic authentication integration guide with official documentation, Web3 wallet integration, and API references
- **`docs/frontend.md`** - React/TypeScript development guide with Wagmi integration patterns and best practices
- **`docs/smart-contracts.md`** - Foundry smart contract development guide with security patterns and testing
- **`docs/deployment.md`** - Deployment procedures for local, testnet, and production environments
- **`docs/troubleshooting.md`** - Common issues and solutions for the entire Web3 stack

### 📖 Documentation Usage
- **Quick Reference**: Use `.cursorrules` for common patterns and project structure
- **Detailed Guides**: Refer to `docs/` files for comprehensive implementation details
- **Official Sources**: `docs/civic.md` contains official Civic documentation
- **Best Practices**: All docs include real-world examples and security considerations

### 🔍 Finding Information
- **Civic Integration**: See `docs/civic.md` for complete official Civic SDK documentation
- **Frontend Development**: See `docs/frontend.md` for React/Wagmi patterns and TypeScript best practices
- **Smart Contracts**: See `docs/smart-contracts.md` for Foundry development and security patterns
- **Deployment**: See `docs/deployment.md` for multi-environment deployment procedures
- **Troubleshooting**: See `docs/troubleshooting.md` for common issues and debug commands

Remember: Always prioritize security, user experience, and code maintainability in Web3 development. 